# -*- coding: utf-8 -*-
"""BurnAnalysis1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PmqWI0deA6mvwzYhNhswK-348XCES2vt

#Preparations
"""

# For graph plotting
import matplotlib.pyplot as plt

# For dataset manipulation
import pandas as pd
pd.options.mode.chained_assignment = None  # default='warn'
import numpy as np

"""#1) Dataset Preparations"""

column_names = ['SiO2', 'Al2O3', 'Fe2O3', 'CaO', 'MgO', 'Na2O','K2O']

raw_dataset = pd.read_csv("data.csv",
                          names=column_names,
                          na_values="?",
                          comment='\t',
                          sep=",",
                          skipinitialspace=True,
                          skiprows=8
                          )
raw_dataset

raw_dataset.columns

raw_dataset.head()

raw_dataset.shape

"""##Null Values"""

# Lets make a copy
new_dataset = raw_dataset.copy()

# Lets check for null values
print(new_dataset.isna().sum())

# Dropping null rows
new_dataset = new_dataset.dropna()

# Checking new dataset
new_dataset.head()

"""#2) New Columns"""

# Abstracting the columns for opperations
new_dataset = raw_dataset.copy()

#Columns
SiO2 = new_dataset['SiO2']
Al2O3 = new_dataset['Al2O3']
Fe2O3 = new_dataset['Fe2O3']
CaO = new_dataset['CaO']
MgO = new_dataset['MgO']
Na2O = new_dataset['Na2O']
K2O = new_dataset['K2O']

"""## FSC"""

'''
Factor de Saturación de Cal
FSC = CaO / (2.8 * SiO2 + 1.18 * Al2O3 + 0.65 * Fe2O3)
'''

#New Columns FSC
new_dataset['FSC'] =  CaO / (2.8 * SiO2 + 1.18 * Al2O3 + 0.65 * Fe2O3)

new_dataset

"""##MS"""

'''
Módulo de Sílice
MS = SiO2 / (Al2O3 + Fe2O3)
'''
new_dataset['MS'] =  SiO2 / (Al2O3 + Fe2O3)

new_dataset

"""##MA"""

'''
Módulo de Aluminio
MS = (Al2O3 / Fe2O3)
'''
new_dataset['MA'] =  (Al2O3 / Fe2O3)

new_dataset

"""##FLP"""

'''
Porcentaje de Fase líquida
FLP = 3.0 * Al2O3 + 2.25 * Fe2O3 + MgO + Na2O + K2O
 -- ssi MgO <= 2
'''

new_dataset['FLP'] = 3.0 * Al2O3 + 2.25 * Fe2O3 + MgO + Na2O + K2O

new_dataset

"""#3) Dataframe Separation"""

'''
Data Frame for: Clinker Burnability Analysis

this data is used for the graph, where:
  MS is 'x' axis
  FSC is 'y' axis

'''
burn_df = new_dataset[['MS', 'FSC']]

burn_df

'''
Data Frame for: Clinker Coating Behavior

this data is used for the graph, where:
  FLP is 'x' axis
  MA is 'y' axis

'''
coat_df = new_dataset[['FLP', 'MA']]

coat_df

"""#4) Analysis

##Burnability Analysis

###Dispersion Plot
"""

#plt.figure(figsize=(20, 6))
plt.scatter(burn_df['MS'], burn_df['FSC'], c='blue', alpha=0.5)  # 'MS' en el eje x, 'FSC' en el eje y

# Añadir etiquetas y título
plt.xlabel('MS')
plt.ylabel('FSC')
plt.title('Clinker Burnability Analysis')

# min and max values from dataset MS and FSC
max_x = np.max(burn_df['MS'])
min_x = np.min(burn_df['MS'])
max_y = np.max(burn_df['FSC'])
min_y = np.min(burn_df['FSC'])

# Dataset population area
xf = [min_x,min_x,max_x,max_x]
yf = [min_y,max_y,max_y,min_y]
plt.fill(xf,yf, alpha=0.1, color='b', edgecolor='b', label='Population Area')

# perey graph comparison
xp = [2.1,3.38,3.12,1.86]
yp = [0.97, 0.895, 0.884, 0.96]
plt.fill(xp,yp, alpha=0.3, color='green', edgecolor='green', label='Perey\'s Graph')

# Mostrar el gráfico
plt.legend()
plt.grid(True)
plt.show()

"""###Statistics"""

burn_df.describe()

"""###Pie and Bars"""

'''
The rationale: normal burnability region is contained in the polygon made by the Perey's Graph points.

Perey's Graph Points:

            ┌──────┬───────┐
            |   X  |   Y   |
      ┌─────┼──────┼───────┤
      |  P1 | 2.1  | 0.97  |
      |  P2 | 3.38 | 0.895 |
      |  P3 | 3.12 | 0.884 |
      |  P4 | 1.86 | 0.96  |
      └─────┴──────┴───────┘

'''

# Points for perey Graph
x1, y1 = 2.1, 0.97
x2, y2 = 3.38, 0.895
x3, y3 = 3.12, 0.884
x4, y4 = 1.86, 0.96

# P1 to P2 linear equation parameters y = mx + b
m12 = (y2 - y1) / (x2 - x1)
b12 = y1 - m12 * x1

# P3 to P2 linear equation parameters y = mx + b
m32 = (y2 - y3) / (x2 - x3)
b32 = y3 - m32 * x3

# P4 to P3 linear equation parameters y = mx + b
m43 = (y3 - y4) / (x3 - x4)
b43 = y4 - m43 * x4

# P4 to P1 linear equation parameters y = mx + b
m41 = (y1 - y4) / (x1 - x4)
b41 = y4 - m41 * x4

# ---- Area constraints featuring the linear ecuations above ----

def ec1(x, y):
  if (y - m12 * x <= b12) : return True
  return False

def ec2(x, y):
  if (y - m32 * x >= b32) : return True
  return False

def ec3(x, y):
  if (y - m43 * x >= b43) : return True
  return False

def ec4(x, y):
  if (y - m41 * x <= b41) : return True
  return False

# ---------------------------------------------------------------

'''
recives: a Point
returns: the burnability evaluation following the next criteria
  * normal : c1 ∧ c2 ∧ c3 ∧ c4  is  TRUE
  * easy :  c2  is  FALSE ∨ c3  is  FALSE
  * hard :  c4  is  FALSE ∨ c1  is  FALSE

'''
def evaluateBurnability(x, y):
  c1 = ec1(x,y)
  c2 = ec2(x,y)
  c3 = ec3(x,y)
  c4 = ec4(x,y)
  if ( (c4==False) | (c1==False)) : return 'hard'
  if ( (c2==False) | (c3==False)) : return 'easy'
  if (c1 & c2 & c3 & c4) : return 'normal'
  return 'none'

evaluateBurnability = np.vectorize(evaluateBurnability)

MS = burn_df['MS']
FSC = burn_df['FSC']
burn_df['burnability'] = evaluateBurnability(MS, FSC)
burn_df

# Count occurrences of 'easy', 'normal', and 'hard' in the 'burnability' column
burn_counts = burn_df['burnability'].value_counts()

# Define colors for the pie chart
colors = ['#ff9999', '#66b3ff', '#99ff99']

# Plotting the pie chart with some style improvements
plt.figure(figsize=(8, 8))
plt.pie(burn_counts, labels=burn_counts.index, colors=colors, autopct='%1.1f%%', startangle=140, pctdistance=0.85, explode=(0.1, 0, 0))
plt.title('Burnability Distribution', fontsize=16, fontweight='bold', color='black')
plt.axis('equal')

# Add a circle at the center to make it look like a donut chart (optional)
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Show the plot
plt.tight_layout()
plt.show()

# Count occurrences of 'easy', 'normal', and 'hard' in the 'burnability' column
burn_counts = burn_df['burnability'].value_counts()

# Plotting the bar chart
plt.figure(figsize=(8, 6))
burn_counts.plot(kind='bar', color=['#ff9999', '#66b3ff', '#99ff99'])
plt.title('Burnability Distribution', fontsize=16, fontweight='bold', color='black')
plt.xlabel('Burnability', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.xticks(rotation=0)  # Rotate x-axis labels if needed
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Add data labels on top of each bar
for i, count in enumerate(burn_counts):
    plt.text(i, count + 0.1, str(count), ha='center', va='bottom')

# Show the plot
plt.tight_layout()
plt.show()

"""##Coating Behavior

###Dispersion Plot
"""

#plt.figure(figsize=(20, 6))
plt.scatter(coat_df['FLP'], coat_df['MA'], c='blue', alpha=0.5, )  # 'MS' en el eje x, 'FSC' en el eje y

# Añadir etiquetas y título
plt.xlabel('FLP')
plt.ylabel('MA')
plt.title('Clinker Coating Behavior')

# min and max values from dataset MS and FSC
max_x = np.max(coat_df['FLP'])
min_x = np.min(coat_df['FLP'])
max_y = np.max(coat_df['MA'])
min_y = np.min(coat_df['MA'])

# Dataset population area
xf = [min_x,min_x,max_x,max_x]
yf = [min_y,max_y,max_y,min_y]
plt.fill(xf,yf, alpha=0.1, color='blue', edgecolor='blue', label='Population Area')

# Normal Coating Region
xc = [23,28,28,23]
yc = [2.5,2.5,1.5,1.5]
plt.fill(xc,yc, alpha=0.1, color='green', edgecolor='green', label='Normal Coating Region')

# Mostrar el gráfico
plt.legend()
plt.grid(True)
plt.show()

"""###Statistics"""

coat_df.describe()

"""###Pie and Bars"""

'''
The rationale: normal coating region is contained in the polygon made by the normal caoting graph points.

Normal Coating Behavior Points:

            ┌──────┬───────┐
            |   X  |   Y   |
      ┌─────┼──────┼───────┤
      |  P1 |  23  |  2.5  |
      |  P2 |  28  |  2.5  |
      |  P3 |  28  |  1.5  |
      |  P4 |  23  |  1.5  |
      └─────┴──────┴───────┘

'''

# ---- Area constraints featuring the limit points ----

def ec1(x):
  return x >= 23

def ec2(x):
  return x <= 28

def ec3(y):
  return y >= 1.5

def ec4(y):
  return y <= 2.5
# -----------------------------------------------------

'''
recives: a Point
returns: the burnability evaluation following the next criteria
  * normal : c1 ∧ c2 ∧ c3 ∧ c4  is  TRUE
  * easy :  c2  is  FALSE ∨ c3  is  FALSE
  * hard :  c4  is  FALSE ∨ c1  is  FALSE

'''
def evaluateCoatingBehavior(x, y):
  if (ec1(x) & ec2(x) & ec3(y) & ec4(y)) : return 'inside'
  return 'outside'

evaluateCoatingBehavior = np.vectorize(evaluateCoatingBehavior)

FLP = coat_df['FLP']
MA = coat_df['MA']
coat_df['behavior'] = evaluateCoatingBehavior(FLP, MA)
coat_df

# Count occurrences of 'inside' and 'outside' in the 'behavior' column
coat_counts = coat_df['behavior'].value_counts()

# Define colors for the pie chart
colors = ['#ff9999', '#66b3ff']

# Plotting the pie chart with some style improvements
plt.figure(figsize=(8, 8))
plt.pie(coat_counts, labels=coat_counts.index, colors=colors, autopct='%1.1f%%', startangle=170, pctdistance=0.85, explode=(0.1, 0))
plt.title('Coating Behavior Distribution', fontsize=16, fontweight='bold', color='black')
plt.axis('equal')

# Add a circle at the center to make it look like a donut chart (optional)
centre_circle = plt.Circle((0,0),0.70,fc='white')
fig = plt.gcf()
fig.gca().add_artist(centre_circle)

# Show the plot
plt.tight_layout()
plt.show()

# Count occurrences of 'inside' and 'outside' in the 'behavior' column
coat_counts = coat_df['behavior'].value_counts()

# Plotting the bar chart
plt.figure(figsize=(8, 6))
coat_counts.plot(kind='bar', color=['#ff9999', '#66b3ff'])
plt.title('Coating Behavior Distribution', fontsize=16, fontweight='bold', color='black')
plt.xlabel('Coating Behavior', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.xticks(rotation=0)  # Rotate x-axis labels if needed
plt.grid(axis='y', linestyle='--', alpha=0.7)

# Add data labels on top of each bar
for i, count in enumerate(coat_counts):
    plt.text(i, count + 0.1, str(count), ha='center', va='bottom')

# Show the plot
plt.tight_layout()
plt.show()